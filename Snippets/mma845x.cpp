/**
 * @file mma845x.cpp
 *
 *  Created on: 22/11/2013
 *      Author: podonoghue
 */
#include "mma845x.h"
#include "delay.h"
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
using namespace USBDM;

#define MMA845x_CTRL_REG1_ACTIVE_MASK         (1<<0)
#define MMA845x_CTRL_REG1_F_READ_MASK         (1<<1)
#define MMA845x_CTRL_REG1_LNOISE_MASK         (1<<2)
#define MMA845x_CTRL_REG1_DR_OFF              (3)
#define MMA845x_CTRL_REG1_DR_MASK             (0x7<<MMA845x_CTRL_REG1_DR_OFF)
#define MMA845x_CTRL_REG1_DR(x)               (((x)<<MMA845x_CTRL_REG1_DR_OFF)&MMA845x_CTRL_REG1_DR_MASK)
#define MMA845x_CTRL_REG1_ASLP_RATE_OFF       (6)
#define MMA845x_CTRL_REG1_ASLP_RATE_MASK      (0x3F<<MMA845x_CTRL_REG1_ASLP_RATE_OFF)
#define MMA845x_CTRL_REG1_ASLP_RATE(x)        (((x)<<MMA845x_CTRL_REG1_ASLP_RATE_OFF)&MMA845x_CTRL_REG1_ASLP_RATE_MASK)

#define MMA845x_CTRL_REG2_MODS_OFF            (0)
#define MMA845x_CTRL_REG2_MODS_MASK           (0x3<<MMA845x_CTRL_REG1_DR_OFF)
#define MMA845x_CTRL_REG2_MODS(x)             (((x)<<MMA845x_CTRL_REG1_DR_OFF)&MMA845x_CTRL_REG1_DR_MASK)
#define MMA845x_CTRL_REG2_SLPE_MASK           (1<<2)
#define MMA845x_CTRL_REG2_SMODS_OFF           (3)
#define MMA845x_CTRL_REG2_SMODS_MASK          (0x3<<MMA845x_CTRL_REG1_DR_OFF)
#define MMA845x_CTRL_REG2_SMODS(x)            (((x)<<MMA845x_CTRL_REG1_DR_OFF)&MMA845x_CTRL_REG1_DR_MASK)
#define MMA845x_CTRL_REG2_RST_MASK            (1<<6)
#define MMA845x_CTRL_REG2_ST_MASK             (1<<7)

#define MMA845x_CTRL_REG3_PP_OD_MASK          (1<<0)
#define MMA845x_CTRL_REG3_IPOL_MASK           (1<<1)
#define MMA845x_CTRL_REG3_WAKE_A_VECM_MASK    (1<<2)
#define MMA845x_CTRL_REG3_WAKE_FFMT_MASK      (1<<3)
#define MMA845x_CTRL_REG3_WAKE_PULSE_MASK     (1<<4)
#define MMA845x_CTRL_REG3_WAKE_INDPRT_MASK    (1<<5)
#define MMA845x_CTRL_REG3_WAKE_TRANS_MASK     (1<<6)
#define MMA845x_CTRL_REG3_FIFO_GATE_MASK      (1<<7)

#define MMA845x_CTRL_REG4_INT_EN_DRDY_MASK    (1<<0)
#define MMA845x_CTRL_REG4_INT_EN_A_VECM_MASK  (1<<1)
#define MMA845x_CTRL_REG4_INT_EN_EN_FFMT_MASK (1<<2)
#define MMA845x_CTRL_REG4_INT_EN_PULSE_MASK   (1<<3)
#define MMA845x_CTRL_REG4_INT_EN_INDPRT_MASK  (1<<4)
#define MMA845x_CTRL_REG4_INT_EN_TRANS_MASK   (1<<5)
#define MMA845x_CTRL_REG4_INT_EN_FIFO_MASK    (1<<6)
#define MMA845x_CTRL_REG4_INT_EN_ASLP_MASK    (1<<7)

#define MMA845x_XYZ_DATA_CFG_FS_OFF           (0)
#define MMA845x_XYZ_DATA_CFG_FS_MASK          (0x03<<MMA845x_XYZ_DATA_CFG_FS_OFF)
#define MMA845x_XYZ_DATA_CFG_FS(x)            (((x)<<MMA845x_XYZ_DATA_CFG_FS_OFF)&MMA845x_XYZ_DATA_CFG_FS_MASK)
#define MMA845x_XYZ_DATA_CFG_HPF_OUT_MASK     (1<<4)

#define MMA845x_STATUS_ZYXDR_MASK   (1<<3)


// Accelerometer registers
enum {
   STATUS,
   F_STATUS = STATUS,
   OUT_X_MSB,
   OUT_X_LSB,
   OUT_Y_MSB,
   OUT_Y_LSB,
   OUT_Z_MSB,
   OUT_Z_LSB,
   Reservedx07,
   Reservedx08,
   F_SETUP,
   TRIG_CFG,
   SYSMOD,
   INT_SOURCE,
   WHO_AM_I,
   XYZ_DATA_CFG,
   HP_FILTER_CUTOFF,
   PL_STATUS,
   PL_CFG,
   PL_COUNT,
   PL_BF_ZCOMP,
   P_L_THS_REG,
   FF_MT_CFG,
   FF_MT_SRC,
   FF_MT_THS,
   FF_MT_COUNT,
   reservedx19,
   reservedx1A,
   reservedx1B,
   reservedx1C,
   TRANSIENT_CFG,
   TRANSIENT_SCR,
   TRANSIENT_THS,
   TRANSIENT_COUNT,
   PULSE_CFG,
   PULSE_SRC,
   PULSE_THSX,
   PULSE_THSY,
   PULSE_THSZ,
   PULSE_TMLT,
   PULSE_LTCY,
   PULSE_WIND,
   ASLP_COUNT,
   CTRL_REG1,
   CTRL_REG2,
   CTRL_REG3,
   CTRL_REG4,
   CTRL_REG5,
   OFF_X,
   OFF_Y,
   OFF_Z,
};

/**
 * Constructor
 *
 * @param[in] i2c                - The I2C interface to use
 * @param[in] accelerometerMode  - Mode of operation (gain and filtering)
 * @param[in] cr1                - Data rate etc (see cr1Value())
 */
MMA845x::MMA845x(USBDM::I2c &i2c, AccelerometerMode accelerometerMode, uint8_t cr1) : i2c(i2c) {
   if (readReg(WHO_AM_I) != WHO_AM_I_VALUE) {
      setErrorCode(E_NO_COMMUNICATION);
      return;
   }
   reset();
   configure(accelerometerMode, cr1);
}

/**
 * Read Accelerometer register
 *
 * @param[in] regNum  - Register number
 */
uint8_t MMA845x::readReg(uint8_t regNum) {
   uint8_t command[1];
   i2c.txRx(DEVICE_ADDRESS, 1, &regNum, sizeof(command), command);
   return command[0];
}

/**
 * Write Accelerometer register
 *
 * @param[in] regNum  - Register number
 * @param[in] value   - Value to write
 */
void MMA845x::writeReg(uint8_t regNum, uint8_t value) {
   uint8_t command[] = {regNum, value};

   i2c.transmit(DEVICE_ADDRESS, sizeof(command), command);
}

/**
 * Reset Accelerometer
 */
void MMA845x::reset(void) {

   writeReg(CTRL_REG2, MMA845x_CTRL_REG2_RST_MASK);

   // Device is not accessible after RESET
   waitUS(1000);
}

/**
 * Put accelerometer into Standby mode
 */
void MMA845x::standby() {

   writeReg(CTRL_REG1, readReg(CTRL_REG1)&~MMA845x_CTRL_REG1_ACTIVE_MASK);
}

/**
 * Put accelerometer into Active mode
 */
void MMA845x::active() {

   writeReg(CTRL_REG1, readReg(CTRL_REG1)|MMA845x_CTRL_REG1_ACTIVE_MASK);
}

/**
 * Obtains measurements from the accelerometer
 *
 * @param[out] status  - Indicates status of x, y & z measurements
 * @param[out] x       - X axis as 16-bit signed value (14-bit range)
 * @param[out] y       - Y axis as 16-bit signed value (14-bit range)
 * @param[out] z       - Z axis as 16-bit signed value (14-bit range)
 *
 * @note Waits until a new measurement is available.
 */
void MMA845x::readAccelerometerXYZ(int &status, int16_t &x, int16_t &y, int16_t &z) {
   uint8_t dataXYZ[7] = {STATUS};

   do {
      // Receive 7 registers (status, X-high, X-low, Y-high, Y-low, Z-high & Z-low)
      i2c.txRx(DEVICE_ADDRESS, 1, sizeof(dataXYZ), dataXYZ);
   } while ((dataXYZ[0] & MMA845x_STATUS_ZYXDR_MASK) == 0);

   // Unpack data and return
   // X,Y & Z values are sign-extended to 16-bit values
   status = dataXYZ[0];
   x = ((int16_t)((dataXYZ[1]<<8)+dataXYZ[2]))>>2;
   y = ((int16_t)((dataXYZ[3]<<8)+dataXYZ[4]))>>2;
   z = ((int16_t)((dataXYZ[5]<<8)+dataXYZ[6]))>>2;
}

/**
 * Configure accelerometer
 *
 * @param[in] accelerometerMode - One of ACCEL_2Gmode etc.
 * @param[in] cr1               - Data rate etc (see cr1Value())
 */
void MMA845x::configure(AccelerometerMode accelerometerMode, uint8_t cr1) {
   writeReg(CTRL_REG1, 0x00);
   writeReg(XYZ_DATA_CFG, accelerometerMode);
   writeReg(CTRL_REG1, cr1);
}

/*!
 * Read ID from accelerometer
 *
 * @return ID value as 8-bit number (0x1A for MMA8451Q)
 */
uint32_t MMA845x::readID(void) {
   uint8_t values[] = {WHO_AM_I};
   i2c.txRx(DEVICE_ADDRESS, 1, sizeof(values), values);
   return values[0];
}

/**
 * Calibrate accelerometer
 *
 * This assumes the accelerometer is level and stationary.
 * If the accelerometer is too far from level then no correction is applied and error returned
 *
 * @return E_NO_ERROR       Success
 * @return E_CALIBRATE_FAIL Calibration failed
 */
ErrorCode MMA845x::calibrateAccelerometer() {

   uint8_t originalControlReg1Value   = readReg(CTRL_REG1);
   uint8_t originalXYXDataConfigValue = readReg(XYZ_DATA_CFG);

   // Make inactive so setting can be modified
   writeReg(CTRL_REG1, 0x00);

   // Clear existing offsets
   static const uint8_t clearOffsets[] = {OFF_X, 0, 0, 0};
   i2c.transmit(DEVICE_ADDRESS, sizeof(clearOffsets), clearOffsets);

   int mode = (originalXYXDataConfigValue&MMA845x_XYZ_DATA_CFG_FS_MASK)>>MMA845x_XYZ_DATA_CFG_FS_OFF;

   static const int calibration2Gs[]     = {4096*8, 2048*8, 1024*8};
   static const int calibrationFactors[] = {8*8, 4*8, 2*8};

   int calibration2G     = calibration2Gs[mode];
   int calibrationFactor = calibrationFactors[mode];

   writeReg(CTRL_REG1, cr1Value(AccelDataRate_200Hz));

   int16_t Xout_Accel_14_bit, Yout_Accel_14_bit, Zout_Accel_14_bit;
   int     Xout_Accel=0, Yout_Accel=0, Zout_Accel=0;

   // Average 8 samples to reduce noise
   for (int i=0; i<8; i++) {
      int status;
      readAccelerometerXYZ(status, Xout_Accel_14_bit, Yout_Accel_14_bit, Zout_Accel_14_bit);
      Xout_Accel += Xout_Accel_14_bit;
      Yout_Accel += Yout_Accel_14_bit;
      Zout_Accel += Zout_Accel_14_bit;
   }

   // Calculate correction
   Xout_Accel = -(Xout_Accel / calibrationFactor);
   Yout_Accel = -(Yout_Accel / calibrationFactor);
   Zout_Accel = -((Zout_Accel - calibration2G) / calibrationFactor);

   // Check if 8-bit 2's complement correction is in range
   bool rangeError = (Xout_Accel<-128) || (Xout_Accel>127) || (Yout_Accel<-128) || (Yout_Accel>127) || (Zout_Accel<-128) || (Zout_Accel>127);

   if (rangeError) {
      return setErrorCode(E_CALIBRATE_FAIL);
   }

   // Make inactive so setting can be modified
   writeReg(CTRL_REG1, 0x10);

   // Set new offsets
   int8_t correction[] = { OFF_X, (int8_t)Xout_Accel, (int8_t)Yout_Accel, (int8_t)Zout_Accel };
   i2c.transmit(DEVICE_ADDRESS, sizeof(correction), (uint8_t*)correction);

   // Restore original settings
   writeReg(CTRL_REG1, originalControlReg1Value);
   return E_NO_ERROR;
}

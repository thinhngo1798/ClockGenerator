/**
 * @file     sht10.h
 * @brief    Interface for SHT10 accelerometer
 *
 * @version  V4.12.1.210
 * @date     18 Nov 2017
 */

#ifndef INCLUDE_USBDM_SHT10_H_
#define INCLUDE_USBDM_SHT10_H_
 /*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
#include "hardware.h"

namespace USBDM {

/**
 * @addtogroup SHT10_Group SHT10 Temperature and Humidity sensor
 * @brief C++ Class providing interface to SHT10
 * @{
 */

/**
 * @brief Class representing an interface for SHT10
 *
 * @tparam ClockGpio GPIO to use for SHT10 clock
 * @tparam DataGpio  GPIO to use for SHT10 Data I/O
 *
 * <b>Example</b>
 * @code
 *    // Declare interface
 *    SHT10<GpioB<2>, GpioB<3> sht10{};
 *
 *    // Start measurement, wait for completion, get result
 *    sht10.startTemperatureMeasurement();
 *    float temperature;
 *    while (!sht10.getTemperature(temperature)) {
 *    }
 *    console.writeln("Temperature = ").write(temperature);
 *
 *    // Start measurement, wait for completion, get result
 *    sht10.startHumidityMeasurement();
 *    float humidity;
 *    while (!sht10.getTemperature(humidity)) {
 *    }
 *    console.writeln("Humidity = ").write(humidity);
 * @endcode
 *
 * @ref sht10-example.cpp
 *
 * @note Starting a measurement and waiting for a result are split into two functions to allow other actions while waiting.
 * @note This code uses bit-banging so timing may need to be adjusted in faster processors.
 */
template <class ClockGpio, class DataGpio>
class SHT10 {

   //using ClockGpio = GpioB<2,ActiveHigh>;
   //using DataGpio  = GpioB<3,ActiveHigh>;

private:

   //! Status/control register value
   uint8_t statusValue;

   //! Linearise factors
   struct LinearFactors {
      float c1,c2,c3; //!< Relative humidity
      float d1,d2;    //!< Temperature
   };

   /**
    * Linerization factors for different resolutions
    */
   static constexpr LinearFactors linearFactors[2] = {
         {-2.0468, 0.0367, -1.5955E-6, -39.7, 0.01},  //!< Higher precision: 12-bit humidity, 14-bit temperature
         {-2.0468, 0.5872, -4.0845E-4, -39.7, 0.04},  //!< Lower precision:   8-bit humidity, 12-bit temperature
   };

   /**
    * Commands for sensor
    */
   enum Commands {
      CommandTemperatureMeasure   = 0b00000011,  //!< Measure temperature (read)
      CommandHumidityMeasure      = 0b00000101,  //!< Measure humidity (read)
      CommandWriteStatus          = 0b00000110,  //!< Status/control register (write)
      CommandReadStatus           = 0b00000111,  //!< Status/control register (read)
      CommandSoftReset            = 0b00000110,  //!< Soft reset (write)
   };

   enum StatusMask : uint8_t {
      StatusMask_lowResolution = 0b00000001, //!< Use low resolution for measurements
      StatusMask_noOtpReload   = 0b00000010, //!< Don't reload OTP data
      StatusMask_heater        = 0b00000100, //!< Enable on-chip heater
      StatusMask_BatteryLevel  = 0b01000000, //!< Battery level < 2.47V
   };
public:

   /**
    * Create and initialise sensor interface
    */
   SHT10() : statusValue(0) {
      reset();
   }

   /**
    * Reset interface and sensor
    */
   void reset() {
      // Data I/O is Open-drain to avoid conflicts with sensor
      DataGpio::setInOut(PinPull_Up, PinDriveStrength_High, PinDriveMode_OpenDrain, PinAction_None, PinFilter_None, PinSlewRate_Fast);
      DataGpio::high();
      DataGpio::setOut();
      ClockGpio::setOutput(PinDriveStrength_High, PinDriveMode_PushPull, PinSlewRate_Fast);

      // Do in case interface is in unknown state
      resetInterface();

      // Set initial mode etc
      statusValue = 0;
      writeStatus(0b00000000);
   }

   /**
    * Reset device interface
    *
    * Sends 9 clock pulse with data high.
    */
   void resetInterface() {
      for (int i=0; i<9; i++) {
         ClockGpio::high();
         ClockGpio::low();
      }
   }

   /**
    * Send transfer start sequence
    */
   void sendStart() {
      // Start
      ClockGpio::high();
      DataGpio::low();
      ClockGpio::low();
      ClockGpio::high();
      DataGpio::high();
      ClockGpio::low();
   }

   /**
    * Write byte to sensor
    *
    * @param[in] data  - Value to write
    *
    * @return Acknowledge value, true on success
    */
   bool sendByte(uint8_t data) {
      uint8_t mask = 0b10000000;
      while (mask != 0) {
         DataGpio::write(data&mask);
         ClockGpio::high();
         mask >>= 1;
         ClockGpio::low();
      }
      // Receive ACK
      DataGpio::high();
      ClockGpio::high();
      bool isAck = DataGpio::read();
      ClockGpio::low();
      return !isAck;
   }

   /**
    * Read byte from sensor
    *
    * @return Value from read
    */
   uint8_t receiveByte() {
      uint8_t data;
      for (int i=0; i<=7; i++) {
         data <<= 1;
         ClockGpio::high();
         data |= DataGpio::read();
         ClockGpio::low();
      }
      // Send ACK
      DataGpio::low();
      ClockGpio::high();
      ClockGpio::low();
      DataGpio::high();
      return data;
   }

   /**
    * Write Status register
    *
    * @param[in] data  - Value to write
    *
    * @return Acknowledge value from sensor, true on success
    */
   bool writeStatus(uint8_t data) {
      sendStart();
      return
            sendByte(CommandWriteStatus) &&
            sendByte(data);
   }

   /**
    * Read status register
    *
    * @return Status register value
    */
   uint8_t readStatus() {
      sendStart();
      sendByte(CommandReadStatus);
      uint8_t data = receiveByte();
      receiveByte();
      return data;
   }

   /**
    * Enable/disable reload of OTP values
    *
    * @param[in] enable true to enable OTP reload
    *
    * @return Acknowledge value from sensor, true on success
    */
   bool enableReloadOtp(bool enable) {
      if (enable) {
         statusValue &= ~StatusMask_noOtpReload;
      }
      else {
         statusValue |= StatusMask_noOtpReload;
      }
     return writeStatus(statusValue);
   }

   /**
    * Enable/disable lower resolution measurements
    *
    * @param[in] enable \n
    *    false => Higher precision: 12-bit humidity, 14-bit temperature\n
    *    true  => Lower precision:   8-bit humidity, 12-bit temperature
    *
    * @return Acknowledge value from sensor, true on success
    */
   bool enableLowResolution(bool enable=true) {
      if (enable) {
         statusValue |= StatusMask_lowResolution;
      }
      else {
         statusValue &= ~StatusMask_lowResolution;
      }
     return writeStatus(statusValue);
   }

   /**
    * Enable/disable on-chip heater
    *
    * @param[in] enable true to enable on-chip heater
    *
    * @return Acknowledge value from sensor, true on success
    */
   bool enableHeater(bool enable=true) {
      if (enable) {
         statusValue |= StatusMask_heater;
      }
      else {
         statusValue &= ~StatusMask_heater;
      }
     return writeStatus(statusValue);
   }

   /**
    * Read Battery level from sensor
    *
    * @return true  Vbat > 2.47
    * @return false Vbat < 2.47
    */
   bool readBatteryLevel() {
      return (readStatus() & StatusMask_BatteryLevel) == 0;
   }

   /**
    * Start temperature measurement
    *
    * @return Acknowledge value, true on success
    *
    * @note Measurement time depends on resolution mode.  Approximately 80/320 ms for a 12/14-bit measurement
    */
   bool startTemperatureMeasurement() {
      sendStart();
      return sendByte(CommandTemperatureMeasure);
   }

   /**
    * Start humidity measurement
    *
    * @return Acknowledge value, true on success
    *
    * @note Measurement time depends on resolution mode.  Approximately 20/80 ms for a 8/12-bit measurement
    */
   bool startHumidityMeasurement() {
      sendStart();
      return sendByte(CommandHumidityMeasure);
   }

   /**
    * Check if measurement data is ready and return raw value if available.
    *
    * @param[out] value Raw Data from measurement
    *
    * @return true if data is available and returned
    */
   bool getMeasurementResult(uint16_t &value) {
      if (DataGpio::isHigh()) {
         return false;
      }
      value = receiveByte();
      value = (value<<8) | receiveByte();
      receiveByte();

      return true;
   }

   /**
    * Convert raw humidity measurement to relative humidity
    *
    * @param[in] lowResolution Indicates if low resolution was used for measurement
    * @param[in] humidity Raw humidity value to convert
    *
    * @return Linearised relative humidity value
    */
   static float constexpr lineariseHumidity(bool lowResolution, uint16_t humidity) {
      return lowResolution?
            (linearFactors[1].c1 + linearFactors[1].c2*humidity + linearFactors[1].c3*humidity*humidity):
            (linearFactors[0].c1 + linearFactors[0].c2*humidity + linearFactors[0].c3*humidity*humidity);
   }

   /**
    * Convert raw temperature measurement to Celsius
    *
    * @param[in] lowResolution Indicates if low resolution was used for measurement
    * @param[in] temperature   Raw temperature value to convert
    *
    * @return Linearised temperature value in Celsius
    */
   static float constexpr lineariseTemperature(bool lowResolution, uint16_t temperature) {
      return lowResolution?
            (linearFactors[1].d1 + linearFactors[1].d2*temperature):
            (linearFactors[0].d1 + linearFactors[0].d2*temperature);
   }

   /**
    * Check if temperature measurement data is ready and return converted and linearised value if so.
    *
    * @param[out] temperature Temperature in Celsius
    *
    * @return true if data is available and returned
    */
   bool getTemperature(float &temperature) {
      uint16_t value;
      if (!getMeasurementResult(value)) {
         return false;
      }
      temperature = lineariseTemperature(statusValue&StatusMask_lowResolution, value);
      return true;
   }

   /**
    * Check if humidity measurement data is ready and return converted and linearised value if so.
    *
    * @param[out] humidity Relative humidity in percent
    *
    * @return true if data is available and returned
    */
   bool getHumidity(float &humidity) {
      uint16_t value;
      if (!getMeasurementResult(value)) {
         return false;
      }
      humidity = lineariseHumidity(statusValue&StatusMask_lowResolution, value);
      return true;
   }

};

/**
 * @}
 */

} // End namespace USBDM

#endif // INCLUDE_USBDM_SHT10_H_

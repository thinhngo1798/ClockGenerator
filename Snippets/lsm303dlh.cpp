/**
 ============================================================================
 * @file     lsm303dlh.cpp
 * @brief    Interface for LSM303DLH 3-axis magnetometer
 * @version  V4.11.1.70
 * @date     18 June 2015
 * @author   podonoghue
 ============================================================================
 */

#include "lsm303dlh.h"
/*
 * *****************************
 * *** DO NOT EDIT THIS FILE ***
 * *****************************
 *
 * This file is generated automatically.
 * Any manual changes will be lost.
 */
using namespace USBDM;

constexpr uint8_t ACCEL_ADDR = 0x13;
constexpr uint8_t MAG_ADDR   = 0x15;

enum Accel_Addr {
   /*                            type  default  */
   CTRL_REG1_A       = 0x20,  /* rw    00000111 */
   CTRL_REG2_A       = 0x21,  /* rw    00000000 */
   CTRL_REG3_A       = 0x22,  /* rw    00000000 */
   CTRL_REG4_A       = 0x23,  /* rw    00000000 */
   CTRL_REG5_A       = 0x24,  /* rw    00000000 */
   HP_FILTER_RESET_A = 0x25,  /* r     - dummy  */
   REFERENCE_A       = 0x26,  /* rw    00000000 */
   STATUS_REG_A      = 0x27,  /* r     00000000 */
   OUT_X_L_A         = 0x28,  /* r     -        */
   OUT_X_H_A         = 0x29,  /* r     -        */
   OUT_Y_L_A         = 0x2A,  /* r     -        */
   OUT_Y_H_A         = 0x2B,  /* r     -        */
   OUT_Z_L_A         = 0x2C,  /* r     -        */
   OUT_Z_H_A         = 0x2D,  /* r     -        */
   INT1_CFG_A        = 0x30,  /* rw    00000000 */
   INT1_SOURCE_A     = 0x31,  /* r     00000000 */
   INT1_THS_A        = 0x32,  /* rw    00000000 */
   INT1_DURATION_A   = 0x33,  /* rw    00000000 */
   INT2_CFG_A        = 0x34,  /* rw    00000000 */
   INT2_SOURCE_A     = 0x35,  /* r     00000000 */
   INT2_THS_A        = 0x36,  /* rw    00000000 */
   INT2_DURATION_A   = 0x37,  /* rw    00000000 */
};

enum Mag_Addr {
   /*                            type  default  */
   CRA_REG_M         = 0x00,  /* rw    00010000 */
   CRB_REG_M         = 0x01,  /* rw    00100000 */
   MR_REG_M          = 0x02,  /* rw    00000011 */
   OUT_X_H_M         = 0x03,  /* r     -        */
   OUT_X_L_M         = 0x04,  /* r     -        */
   OUT_Y_H_M         = 0x05,  /* r     -        */
   OUT_Y_L_M         = 0x06,  /* r     -        */
   OUT_Z_H_M         = 0x07,  /* r     -        */
   OUT_Z_L_M         = 0x08,  /* r     -        */
   SR_REG_Mg         = 0x09,  /* r     00000000 */
   IRA_REG_M         = 0x0A,  /* r     01001000 */
   IRB_REG_M         = 0x0B,  /* r     00110100 */
   IRC_REG_M         = 0x0C,  /* r     00110011 */
};

#define LSM303DLH_SR_LOCK   (1<<1)  // Register values are locked when:
//                               //  1. some, but not all of, the six data output registers have been read,
//                               //  2. mode register has been read.
//                               // Remains locked until:
//                               //  1. all six result bytes have been read,
//                               //  2. the mode register is changed,
//                               //  3. the measurement configuration (CRA) is changed,
//                               //  4. power is reset.
#define LSM303DLH_SR_RDY    (1<<0)  // Ready Bit.
//                               // Set when data is written to all six data registers.
//                               // Cleared when device initiates a write to the data output registers and
//                               // after one or more of the data output registers are written to.

/**
 * Constructor
 *
 * @param i2c - I2C interface to use
 *
 */
LSM303DLH::LSM303DLH(I2c &i2c) : i2c(i2c) {

   // Set default settings
   static const uint8_t settings[] = {
         CRA_REG_M,
         craValue(MagAverages_1, MagBias_Normal, MagDataRate_1_5_Hz),
         crbValue(MagRange_4_7),
         MagMode_Sleep,
   };
   i2c.transmit(magAddress, sizeof(settings), settings);

#ifdef DEBUG_BUILD
   // Read back - debug only
   uint8_t confirm[3];
   i2c.txRx(magAddress, 1, settings, sizeof(confirm), confirm);
#endif
}

/**
 * Read ID from compass
 *
 * @return ID value as 24-bit number
 */
uint32_t LSM303DLH::readID(void) {
   uint8_t values[] = {IRA_REG_M, 0x00, 0x00};
   i2c.txRx(magAddress, 1, sizeof(values), values);
   return (values[0]<<16)|(values[1]<<8)|values[2];
}

/**
 * Set Accelerometer configuration
 *
 * @param accelDataRate Rate of measurements
 * @param xEn           Enable X axis measurements
 * @param yEn           Enable Y axis measurements
 * @param zEn           Enable Z axis measurements
 */
void LSM303DLH::setAccelConfiguration(AccelDataRate accelDataRate,  bool xEn, bool yEn, bool zEn) {
   // Set CR1
   static const uint8_t controlReg_Settings[] = {
         /* addr      */ CTRL_REG1_A,
         /* CTRL_REG1 */ cr1Value(accelDataRate, xEn, yEn, zEn),
         /* CTRL_REG2 */ 0,
         /* CTRL_REG3 */ 0,
         /* CTRL_REG4 */ 0,
         /* CTRL_REG5 */ 0,
   };
   i2c.transmit(accelAddress, sizeof(controlReg_Settings), controlReg_Settings);
}

/**
 * Set compass gain and hence range on all channels
 *
 * @param magRange                                      \n
 * G    Recommended   Gain        Resolution         \n
 * 321  Sensor Range  (LSB/Gauss) (mGauss/LSB)       \n
 * 000   +/- 0.88 Ga    1370        0.73             \n
 * 001   +/- 1.3  Ga    1090        0.92 (default)   \n
 * 010   +/- 1.9  Ga     820        1.22             \n
 * 011   +/- 2.5  Ga     660        1.52             \n
 * 100   +/- 4.0  Ga     440        2.27             \n
 * 101   +/- 4.7  Ga     390        2.56             \n
 * 110   +/- 5.6  Ga     330        3.03             \n
 * 111   +/- 8.1  Ga     230        4.35
 */
void LSM303DLH::setMagRange(MagRange magRange) {
   static const uint8_t controlRegB_Setting[] = {
         /* Addr */ CRB_REG_M,
         /* CRB  */ crbValue(magRange)};
   i2c.transmit(magAddress, sizeof(controlRegB_Setting), controlRegB_Setting);
}

/**
 * Set Magnetometer configuration
 *
 * @param[in] magBias
 * @param[in] magDataRate
 * @param[in] magRange
 * @param[in] magAverages
 */
void LSM303DLH::setMagConfiguration(MagDataRate magDataRate, MagRange magRange, MagAverages magAverages, MagBias magBias) {
   // Set CRA & CRB
   static const uint8_t controlReg_Settings[] = {
         /* Addr */ CRA_REG_M,
         /* CRA  */ craValue(magAverages, magBias, magDataRate),
         /* CRB  */ crbValue(magRange)};
   i2c.transmit(magAddress, sizeof(controlReg_Settings), controlReg_Settings);
}

/**
 * Do a single triggered measurement of magnetic field
 *
 * @param x - X intensity
 * @param y - Y intensity
 * @param z - Z intensity
 */
void LSM303DLH::doMeasurement(Vector &vector) {
   static const uint8_t modeReg_Setting[] = {MR_REG_M, MagMode_Single};
   i2c.transmit(magAddress, sizeof(modeReg_Setting), modeReg_Setting);

   static const uint8_t statusRegAddress[] = {SR_REG_Mg};
   uint8_t status[1];
   do {
      i2c.txRx(magAddress, sizeof(statusRegAddress), statusRegAddress, sizeof(status), status);
   } while ((status[0]&LSM303DLH_SR_RDY) == 0);

   static const uint8_t resultRegAddress[] = {OUT_X_H_M};
   uint8_t values[6];
   i2c.txRx(magAddress, sizeof(resultRegAddress), resultRegAddress, sizeof(values), values);

   vector.x = (values[0]<<8)+values[1];
   vector.z = (values[2]<<8)+values[3];
   vector.y = (values[4]<<8)+values[5];
}

//   void LSM303DLH::calibrate() {
//      const uint8_t cra[]     = {CRA_REG_M,  0x71};
//      i2c.transmit(magAddress,  sizeof(cra), cra);
//      const uint8_t crb[]     = {CRB_REG_M,  0xA0};
//      i2c.transmit(magAddress,  sizeof(cra), crb);
//      const uint8_t mode[]    = {MR_REG_M,   0x00};
//      i2c.transmit(magAddress, sizeof(cra), mode);
//
//      uint8_t status[1];
//      static const uint8_t statusRegAddress[] = {SR_REG_Mg};
//      do {
//         i2c.txRx(magAddress, sizeof(statusRegAddress), statusRegAddress, sizeof(status), status);
//      } while ((status[0]&LSM303DLH_SR_RDY) == 0);
//
//      static const uint8_t resultRegAddress[] = {OUT_X_H_M};
//      uint8_t values[6];
//      i2c.txRx(magAddress, sizeof(resultRegAddress), resultRegAddress, sizeof(values), values);
//
//      int x = (int16_t)((values[0]<<8)+values[1]);
//      int z = (int16_t)((values[2]<<8)+values[3]);
//      int y = (int16_t)((values[4]<<8)+values[5]);
//   }
